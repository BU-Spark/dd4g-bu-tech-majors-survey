---
title: "Stan Model"
author: "Daniel Sussman"
date: "2023-03-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
library(rstan)
options(mc.cores = parallel::detectCores())
```


```{stan model_from_cgpt, output.var="stan_sat_model"}
data {
  int<lower=1> N;                     // Number of observations
  
  int<lower=1> C;                     // Number of response levels
  int<lower=1, upper=C> response[N];  // Vector of responses

  int<lower=1> D;                     // Number of departments
  int<lower=1, upper=D> dept[N];      // Vector of department indicator
  
  int<lower=1> L;                     // Number of course levels
  int<lower=1, upper=L> level[N];     // Vector of level indicators
  
  int<lower=1> K;                     // Number of courses
  int<lower=1, upper=D> course_dept[K];
  int<lower=1, upper=D> course_level[K];
  int<lower=1, upper=K> course[N];    // Vector of course indicators
  
  cov_matrix[K] course_cov;
  vector[K] course_mu;
  
  cov_matrix[D] dept_cov;
  vector[D] dept_mu;
}

parameters {
  // vector[D] dept_offset;      // Department level offset
  vector[L-1] level_offset_raw;     // Level level offset
  vector[K] course_offset_raw;  // course level offset
  // real<lower=0> sigma_dept;   // Standard deviation of department offsets
  real<lower=0> sigma_level;  // Standard deviation of level offsets
  real<lower=0> sigma_course; // Standard deviation of course offsets
  ordered[C - 1] c;
}
 
transformed parameters {
//  ordered[C - 1] c;
//  c[2:(C-1)] = c_raw;
//  c[1] = 0;
  
  vector[L] level_offset;
  level_offset[2:L] = level_offset_raw;
  level_offset[1] = 0;
    
  // vector[D] dept_offset;
  // dept_offset[2:D] = dept_offset_raw;
  // dept_offset[1] = -sum(dept_offset_raw);
  
  vector[K] course_offset;
  for (k in 1:K){
     course_offset[k] = course_offset_raw[k] +
       // dept_offset[course_dept[k]] +
       level_offset[course_level[k]];
  }
}

model {
  // Priors
//   for (d in 1:(D-1)){
    // dept_offset_raw[d] ~ normal(0, sigma_dept);
  // }
  
  // dept_offset ~ multi_normal(dept_mu, sigma_dept * dept_cov);
  for (l in 1:(L-1)){
    level_offset_raw[l] ~ normal(0, sigma_level);
  }
  course_offset_raw ~ multi_normal(course_mu, sigma_course * course_cov);
  
  // sigma_dept ~ cauchy(0, 1);
  sigma_level ~ cauchy(0, 1);
  sigma_course ~ cauchy(0, 1);

  // Likelihood
  for (n in 1:N) {
    real theta = course_offset[course[n]];
       // level_offset[level[n]] +  dept_offset[dept[n]] + 
    response[n] ~ ordered_logistic(theta, c);
  }
}

```

```{r load_data_and_fns, echo=FALSE}
source(here::here("R/source_all.R"))
```

```{r setup_course_ldf}
ddf_s <- ddf %>%
  mutate(
    gender = as_factor(ifelse(
      str_detect(gender, "not listed"),
      "Pref. not listed",
      gender
    )),
    international = as_factor(replace_na(international, "No response")),
    first_gen = as_factor(replace_na(first_gen, "No response"))
  ) %>%
  simplify_race_var()

course_num_re <- "[A-Z]{3} [A-Z]{2}\\W*[0-9]{3}"
course_satisfaction_q <- original_question_df %>%
  filter(
    str_detect(question_text, "satisfied"),
    str_detect(question_text, "agreement", negate = TRUE)
  ) %>%
  mutate(question_text = str_extract(question_text, course_num_re))
satisfaction_level <-
  c(
    "Extremely dissatisfied",
    "Somewhat dissatisfied",
    "Neither satisfied nor dissatisfied",
    "Somewhat satisfied",
    "Extremely satisfied"
  )

course_ldf_orig <- ddf_s %>%
  pivot_longer(
    cols = course_satisfaction_q$question_id,
    names_to = "question_id",
    values_to = "response",
    values_drop_na = TRUE
  ) %>%
  filter(response != "Did not take this course.") %>%
  left_join(course_satisfaction_q, by = "question_id") %>%
  mutate(
    response =
     factor(
       response,
       levels = satisfaction_level,
       ordered = TRUE
    )
  ) %>% 
  select(response, course_orig = question_text)
```

```{r}
course_ldf <- course_ldf_orig %>%
  mutate(
    dept_orig = str_sub(course_orig, end = 6),
    level_orig = as.integer(str_extract(course_orig, "\\d"))
  )


course_ldf <- course_ldf %>% 
  mutate(
    dept = fct_lump_min(dept_orig, min = 100),
    course = fct_lump_min(course_orig, min = 20),
    level = ifelse(level_orig > 2, "Upper", "Lower")
  ) %>%
  group_by(dept, level) %>% 
  mutate(w = n_distinct(course)) %>%
  group_by(course) %>% 
  mutate(w = w / n()) %>% 
  ungroup() %>% 
  mutate(
    course = fct_lump_min(course, min = 2, w = w)
  ) %>%
  select(-w) %>%
  filter(course != "Other")
course_ldf %>% 
  count(level, dept, course) %>% 
  arrange(n) %>% 
  print() %>% 
  count(level, dept) %>% 
  arrange(n)
```


```{r stan_param}
to_int <- function(.) as.integer(as_factor(.))
  # int<lower=1> N;                     // Number of observations
N <- nrow(course_ldf)

  # int<lower=1> C;                     // Number of response levels
  # int<lower=1, upper=C> response[N];  // Vector of responses
C <- nlevels(course_ldf$response)
response <- as.integer(course_ldf$response)

  # int<lower=1> D;                     // Number of departments
  # int<lower=1, upper=D> dept[N];      // Vector of department indicators
dept <- to_int(course_ldf$dept)
D <- max(dept)
dept_mu <- rep(0, D)
dept_cov <- diag(1 + 1.001 / (D-1), D) - 1 / (D-1)

  # int<lower=1> L;                     // Number of course levels
  # int<lower=1, upper=L> level[N];     // Vector of level indicators
level <- to_int(course_ldf$level)
L <- max(level)
  
  # int<lower=1> K;                     // Number of courses
  # int<lower=1, upper=K> course[N];    // Vector of course indicators
course_dept <- course_ldf %>%
  distinct(course, dept) %>%
  arrange(course) %>% 
  pull(dept) %>% 
  to_int()

course_level <- course_ldf %>%
  distinct(course, level) %>%
  arrange(course) %>% 
  pull(level) %>% 
  to_int()

course <- to_int(course_ldf$course)
K <- max(course)
course_mu <- rep(0, K)
course_cov <- diag(1 + 1.001 / (K-1), K) - 1 / (K-1)


sampling_data <- 
    list(
      N = N,
      C = C,
      response = response,
      D = D,
      dept = dept,
      dept_cov = dept_cov,
      dept_mu = dept_mu,
      L = L,
      level = level,
      K = K,
      course = course,
      course_dept = course_dept,
      course_level = course_level,
      course_cov = course_cov,
      course_mu = course_mu
    )
```


```{r}
sat_model_fit <- sampling(
  stan_sat_model,
  sampling_data,
  chains = 4,
  iter = 3000
)
```


```{r}
fit_tbl <- as_tibble(as.data.frame(sat_model_fit))
cor_mat <- fit_tbl %>% cor()
(corr_tbl <- as_tibble(cor_mat) %>%
  mutate(v1 = rownames(cor_mat)) %>% 
  pivot_longer(-v1, names_to = "v2", values_to = "cor") %>%
  # filter(is.na(cor)) %>% 
  filter(v1 < v2) %>%
  filter(!str_detect(str_c(v1,v2), "((_)\\[|lp_)"), !is.na(cor)) %>%
  arrange(-cor))
corr_tbl %>% ggplot(aes(x = v1, y=v2, fill = cor)) + geom_tile() + scale_fill_gradient2()


fit_tbl %>% ggplot(aes(x = `c[3]`, y = `c[4]`))+geom_point(alpha = .333)

course_ldf %>% count(course)
```
    
```{r}
sat_model_sum <- sat_model_fit %>% summary() %>% as.data.frame() %>% as_tibble() %>% mutate(var = names(sat_model_fit), .before = 1)
sat_model_sum %>% select(var, summary.n_eff, summary.Rhat) %>% View
```


```{r}
plot(sat_model_sum, names(sat_model_sum) %>% str_subset("course_offset\\[") %>% head(4))
```
